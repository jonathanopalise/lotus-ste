$00079412 : 48e4 fcf0                          movem.l   d0-d5/a0-a3,-(a4)
$00079416 : 48e4 fcf0                          movem.l   d0-d5/a0-a3,-(a4)
$0007941a : 48e4 fcf0                          movem.l   d0-d5/a0-a3,-(a4)
$0007941e : 48e4 fcf0                          movem.l   d0-d5/a0-a3,-(a4)
$00079422 : 51cf ffee                          dbra      d7,$79412
$00079426 : 3e2e 005e                          move.w    $5e(a6),d7
$0007942a : 6700 008a                          beq       $794b6
$0007942e : 227c 0002 7800                     movea.l   #$27800,a1   ; base address of mountain data
$00079434 : 322e 0058                          move.w    $58(a6),d1   ; side scroll value
$00079438 : 0241 0fff                          andi.w    #$fff,d1     ; normalise side scroll value into 0-4095 range
$0007943c : 3001                               move.w    d1,d0        ; d0 = side scroll value normalised into 0-4095
$0007943e : e941                               asl.w     #4,d1        ; d1 = (side scroll value normalised into 0-4095) * 16
$00079440 : 9240                               sub.w     d0,d1        ; d1 = ((side scroll value normalised into 0-4095) * 16) - (side scroll value normalised into 0-4095)
$00079442 : ec49                               lsr.w     #6,d1        ; d1 = (((side scroll value normalised into 0-4095) * 16) - (side scroll value normalised into 0-4095)) * 64
$00079444 : b27c 0140                          cmp.w     #$140,d1
$00079448 : 6506                               bcs.s     $79450
$0007944a : 0441 0140                          subi.w    #$140,d1
$0007944e : 60f4                               bra.s     $79444
------------------------------------------------------------------------------------------------------------------------------------
$00079450 : 3001                               move.w    d1,d0           ; this is the 0-319 value!
$00079452 : e849                               lsr.w     #4,d1
$00079454 : 3401                               move.w    d1,d2
$00079456 : d241                               add.w     d1,d1
$00079458 : d242                               add.w     d2,d1
$0007945a : d241                               add.w     d1,d1
$0007945c : d2c1                               adda.w    d1,a1           ; update source address (x position - offset within line)
----------------------------------------------------------------------------------------------------
$0007945e : 45f9 0007 94ba                     lea       $794ba,a2       ; base address of unrolled looop
$00079464 : d4c1                               adda.w    d1,a2           ; add starting point within unrolled loop
-----------------------------------------------------------------------------------------------------
$00079466 : 382e 0060                          move.w    $60(a6),d4      ; horizon height?
$0007946a : 3204                               move.w    d4,d1           ; copy to d1
$0007946c : e944                               asl.w     #4,d4           ; multiply by 16
$0007946e : 9841                               sub.w     d1,d4           ; (multiply by 15)
$00079470 : e744                               asl.w     #3,d4           ; (multiply by 120)
$00079472 : d2c4                               adda.w    d4,a1           ; update source address (y position - line)
--------------------------------------------------------------------------------------------
CONFIRMED THAT DISABLING THIS BLOCK ELIMINATES PRESHIFTING BUT DOES NOTHING ELSE

$00079474 : 0240 000f                          andi.w    #$f,d0          ; preshift logic? redundant?
$00079478 : 0a40 000f                          eori.w    #$f,d0          ; preshift logic? redundant?
$0007947c : e448                               lsr.w     #2,d0           ; preshift logic? redundant?
$0007947e : 3200                               move.w    d0,d1           ; preshift logic 1 - redundant?
$00079480 : e941                               asl.w     #4,d1           ; preshift logic 2 - redundant?
$00079482 : 9240                               sub.w     d0,d1           ; preshift logic 3 - redundant?
$00079484 : e141                               asl.w     #8,d1           ; preshift logic 4 - redundant?
$00079486 : d2c1                               adda.w    d1,a1           ; update source address (set preshifted version)
--------------------------------------------------------------------------------------------------
$00079488 : 302e 005c                          move.w    $5c(a6),d0      ; get a variable related to horizon
$0007948c : 3200                               move.w    d0,d1           ; d1 overwritten here suggests that the above preshift logic is redundant
$0007948e : d040                               add.w     d0,d0
$00079490 : d040                               add.w     d0,d0
$00079492 : d041                               add.w     d1,d0
$00079494 : eb40                               asl.w     #5,d0           ; multiply by 32
$00079496 : 2046                               movea.l   d6,a0           ; d6 must be destination address stored from earlier on
$00079498 : d0c0                               adda.w    d0,a0           ; update destination - we need to keep this
$0007949a : 72ff                               moveq     #$ff,d1         ; this is the word value for the hardcoded words
$0007949c : 5347                               subq.w    #1,d7
$0007949e : 3f2a 007c                          move.w    $7c(a2),-(sp)   ; push the existing instruction onto the stack
$000794a2 : 357c 4e75 007c                     move.w    #$4e75,$7c(a2)  ; replace it with an rts
$000794a8 : 4e92                               jsr       (a2)            ; draw one line
$000794aa : d2fc 0078                          adda.w    #$78,a1         ; update source
$000794ae : 51cf fff8                          dbra      d7,$794a8       ; next line
$000794b2 : 355f 007c                          move.w    (sp)+,$7c(a2)   ; restore previous instruction
$000794b6 : 6000 00f2                          bra       $795aa          ; go to code after the unrolled loop (which will go on to render the sky)
-- each iteration is 6 bytes -----------------------------------------------------------------------------------
$000794ba : 20d9                               move.l    (a1)+,(a0)+
$000794bc : 30c1                               move.w    d1,(a0)+
$000794be : 30d9                               move.w    (a1)+,(a0)+
-- each iteration is 6 bytes -----------------------------------------------------------------------------------
$000794c0 : 20d9                               move.l    (a1)+,(a0)+
$000794c2 : 30c1                               move.w    d1,(a0)+
$000794c4 : 30d9                               move.w    (a1)+,(a0)+
$000794c6 : 20d9                               move.l    (a1)+,(a0)+

example 794a8 addresses:
- 000794BA (rts written to 79536)

so this is what gets executed:
$000794ba : 20d9                               move.l    (a1)+,(a0)+
$000794bc : 30c1                               move.w    d1,(a0)+
$000794be : 30d9                               move.w    (a1)+,(a0)+

$000794c0 : 20d9                               move.l    (a1)+,(a0)+
$000794c2 : 30c1                               move.w    d1,(a0)+
$000794c4 : 30d9                               move.w    (a1)+,(a0)+

$000794c6 : 20d9                               move.l    (a1)+,(a0)+
$000794c8 : 30c1                               move.w    d1,(a0)+
$000794ca : 30d9                               move.w    (a1)+,(a0)+

$000794cc : 20d9                               move.l    (a1)+,(a0)+
$000794ce : 30c1                               move.w    d1,(a0)+
$000794d0 : 30d9                               move.w    (a1)+,(a0)+

$000794d2 : 20d9                               move.l    (a1)+,(a0)+
$000794d4 : 30c1                               move.w    d1,(a0)+
$000794d6 : 30d9                               move.w    (a1)+,(a0)+

$000794d8 : 20d9                               move.l    (a1)+,(a0)+
$000794da : 30c1                               move.w    d1,(a0)+
$000794dc : 30d9                               move.w    (a1)+,(a0)+

$000794de : 20d9                               move.l    (a1)+,(a0)+
$000794e0 : 30c1                               move.w    d1,(a0)+
$000794e2 : 30d9                               move.w    (a1)+,(a0)+

$000794e4 : 20d9                               move.l    (a1)+,(a0)+
$000794e6 : 30c1                               move.w    d1,(a0)+
$000794e8 : 30d9                               move.w    (a1)+,(a0)+

$000794ea : 20d9                               move.l    (a1)+,(a0)+
$000794ec : 30c1                               move.w    d1,(a0)+
$000794ee : 30d9                               move.w    (a1)+,(a0)+

$000794f0 : 20d9                               move.l    (a1)+,(a0)+
$000794f2 : 30c1                               move.w    d1,(a0)+
$000794f4 : 30d9                               move.w    (a1)+,(a0)+

$000794f6 : 20d9                               move.l    (a1)+,(a0)+
$000794f8 : 30c1                               move.w    d1,(a0)+
$000794fa : 30d9                               move.w    (a1)+,(a0)+

$000794fc : 20d9                               move.l    (a1)+,(a0)+
$000794fe : 30c1                               move.w    d1,(a0)+
$00079500 : 30d9                               move.w    (a1)+,(a0)+

$00079502 : 20d9                               move.l    (a1)+,(a0)+
$00079504 : 30c1                               move.w    d1,(a0)+
$00079506 : 30d9                               move.w    (a1)+,(a0)+

$00079508 : 20d9                               move.l    (a1)+,(a0)+
$0007950a : 30c1                               move.w    d1,(a0)+
$0007950c : 30d9                               move.w    (a1)+,(a0)+

$0007950e : 20d9                               move.l    (a1)+,(a0)+
$00079510 : 30c1                               move.w    d1,(a0)+
$00079512 : 30d9                               move.w    (a1)+,(a0)+

$00079514 : 20d9                               move.l    (a1)+,(a0)+
$00079516 : 30c1                               move.w    d1,(a0)+
$00079518 : 30d9                               move.w    (a1)+,(a0)+

$0007951a : 20d9                               move.l    (a1)+,(a0)+
$0007951c : 30c1                               move.w    d1,(a0)+
$0007951e : 30d9                               move.w    (a1)+,(a0)+

$00079520 : 20d9                               move.l    (a1)+,(a0)+
$00079522 : 30c1                               move.w    d1,(a0)+
$00079524 : 30d9                               move.w    (a1)+,(a0)+

$00079526 : 20d9                               move.l    (a1)+,(a0)+
$00079528 : 30c1                               move.w    d1,(a0)+
$0007952a : 30d9                               move.w    (a1)+,(a0)+

$0007952c : 20d9                               move.l    (a1)+,(a0)+
$0007952e : 30c1                               move.w    d1,(a0)+
$00079530 : 30d9                               move.w    (a1)+,(a0)+

$00079532 : 92fc 0078                          suba.w    #$78,a1
$00079536 : 4e75                               rts




INIT

dest_y_increment = 0

FIRST PASS
source = base_a1
destination = base_a0
source_x_increment = 6
dest_x_increment = 8

source word 0 => destination word 0
source word 3 => destination word 4
source word 6 => destination word 8

SECOND PASS
source = base_a1 + 2
destination = base_a1 + 2
source_x_increment = 6
dest_x_increment = 8

source word 1 => destination word 1
source word 4 => destination word 5
source word 7 => destination word 9

THIRD PASS
source = (N/A)
destination = base_a1 + 4
source_x_increment = (N/A)
dest_x_increment = 8

hardcoded     => destination word 2
hardcoded     => destination word 6
hardcoded     => destination word 10

FOURTH PASS
source = base_a1 + 4
destination = base_a1 + 6
source_x_increment = 6
dest_x_increment = 8

source word 2 => destination word 3
source word 5 => destination word 7       
source word 8 => destination word 11

- so this is 20 repetitions of the macro

each repetition:
- copies 2 words from a1 to a0, incrementing each as it goes
- then copies a fixed value word (in d1) to a0, incrementing a0
- then copies a word from a1 to a0, incrementing both
- so for each iteration, we use 3 words of source data, and 4 words of destination data

so our blitter implementation needs the following passes:
- copy word from base_a1 to base_a0, skip 3 source words, skip 3 dest words
- copy word from base_a1+2 to base_a0+2, skip 3 source words, skip 3 dest words
- copy word from base_a1+6 to base_a0+6, skip 3 source words, skip 3 dest words

DON'T FORGET THIS AT THE END
$00079532 : 92fc 0078                          suba.w    #$78,a1
- we shouldn't need this if we can work out smooth scrolling on the Blitter

this seems to change the source offset to the correct preshifted version
$00079486 : d2c1                               adda.w    d1,a1
examples of d1 at this location:
- 0x0 (absolute 0x27800)
- 0x0F00 (absolute 0x27800)
- 0x1E00 (absolute 0x29600)
- 0x2D00 (absolute 0x2a500)
How much storage?
- 3840 bytes per preshifted version
- 120 bytes per line
- 32 lines
- how can we smooth scroll through 3bpp data?
- might be fine - do we just need to add/sub 6 bytes rather than 4 bytes for each 16 pixels?
- we need to transform a value from a 0-4095 range to 0-319 range
- maybe a lookup table - 512 to 320? would need to be 1k
- we could expand this to a 2k lookup with alternating bytes providing 

The base address of the mountains data appears to be $27800

What does this do? address is 7c59e
$00079434 : 322e 0058                          move.w    $58(a6),d1
- This is the mountains side scrolling value!
- It seems to wrap at 0xfff (decimal 4096)
Questions:
- How wide in pixels is the mountain bitmap?
- Is it loaded from disk in preshifted format, or is the preshifting done at runtime?
- Can we dispense with the preshifted version, and replace it with an unpreshifted version?


b ($7c59e).w ! ($7c59e).w :trace
